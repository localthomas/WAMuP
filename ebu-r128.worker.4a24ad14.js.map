{"mappings":"AAGA,IAAOA,YAAKC,GAAAA,EACC,UAAG,YADJA,EAEC,UAAG,aAFJA,IAAAA,EAAL,WCOCC,UAAAC,oCAGAC,QACAC,QAAMC,MAAM,yBAEZ,MAAKC,EAAgBC,SAEjBD,UAAME,IAASC,EAAfC,WAAAC,EADA,KACAC,IACA,MAAKC,EAAAA,IAAAA,EAERC,KAAAD,mCA0GRD,EAAAG,EAAAP,GAED,OAASQ,EAAkBJ,EAAoBG,EAAoBP,EAAgD,IA5G1GS,CAAAL,EAAAD,EAAAH,IACJM,KAAAI,mCA6GJN,EAAAG,EAAAP,GAED,OAASW,EAAiBP,EAAoBG,EAAoBP,EAAwCY,GA/GrGC,CAAAT,EAAAD,EAAAH,eAQGc,EAAKhB,EAAUiB,GAInBV,OAFCC,KAAAR,UAAAiB,WAAAD,EAAA,KAEDT,4BAEcb,QApClBwB,YAqCYC,CAFaC,KAAA3B,EAAA4B,UAIpBF,SAAAA,8BAIazB,QA3ClBwB,YA4CYC,CAFaC,KAAA3B,EAAA6B,UAIpBH,SAAAA,gBAIAI,GA7C6Cf,KAAAgB,KAAAN,YAAAK,sBAqD7B,iBAHE5B,SAKCQ,EAGpBsB,UAAYrB,gBACHsB,eACAC,EAAYA,EAAjBA,EAAAC,GACApB,KAAKoB,aAALxB,EAAuBwB,EAC1BpB,KAAAmB,UAAAA,EAEDV,KAAAA,gBAAmCW,aAE3BZ,cAEaa,CAAAA,EAAYC,KACpBtB,KAAAuB,UAAAD,KAAAtB,KAAAuB,UAAAD,GAAA,IAAAE,EAAAxB,KAAAkB,cAAAO,IAELzB,KAAKuB,YAAUD,WA4CJI,GAEnB,IAAAC,EAAU,EACb,IAAA,MAAAD,KAAAD,EAAAE,GAAAD,EAAAA,EAED,OAASE,EAAAA,EAAAA,OAjDmCC,CAAhCJ,QAEPzB,KAAAuB,UAAAD,GAAAQ,KAAAD,kBAOQE,EAALC,GAEIhC,KAAK+B,aAAaE,KAASC,KAA3BH,aAA0CZ,GACrCY,IAGT/B,KAAKoB,aAAAA,GAAqBW,QAAAA,GAC7B/B,KAAA+B,aAAAE,GAAAC,QAAAlC,KAAAmB,YAAAnB,KAAA+B,aAAAE,GAAAjC,KAAA+B,aAAAE,GAAAE,MAAA,EAAAnC,KAAAmB,YArCkBnB,KAAAoB,gBAAApB,KAAA+B,qBA6CnBd,eACI,cACKmB,EAAWC,GACnBrC,KAAAsC,OAAA,IAAAC,aAAAL,GAEGlC,KAACwC,SAAwBH,oBAGjBX,KAAKU,EACLpC,KAAKyC,cAALzC,KAAAsC,OAAAJ,SACHlC,KAAAoC,SAAApC,KAAAsC,OAAAH,SACDnC,KAAKsC,aAAYG,GAEpBzC,KAAAsC,OAAAtC,KAAAyC,cAAAf,EACJ1B,KAAAyC,yBAqBGd,EAAJ7B,EAAAG,EAAAP,EAAAY,GACA,MAAKa,EAAOc,KAASS,MAAAA,EAAc5C,OAC/B6B,EAAMgB,MACN,MAAIC,EAAaF,KAAjB5C,EAAA+C,UAAA,CACA,MAAIC,EAAJpD,EAAAuC,GACA,IAAAW,EAAW,EAEHA,EAAAA,MACAE,MAAMC,EAANf,KAAAc,EAAAA,UAAAA,EAAAA,IACHF,IAEFE,GAAUd,GAEjBL,GAAOgB,GAAeK,EAAKC","sources":["src/workers/audio-worklets/message-types.ts","src/workers/audio-worklets/ebu-r128.worker.ts"],"sourcesContent":["/**\r\n * LoudnessType is used to signal the type of a loudness value.\r\n */\r\nexport enum LoudnessType {\r\n    Momentary = \"momentary\",\r\n    ShortTerm = \"shortTerm\",\r\n};\r\n\r\n/**\r\n * LoudnessMessage is used as the message between an AudioWorklet and the main Thread.\r\n */\r\nexport type LoudnessMessage = {\r\n    type: LoudnessType;\r\n    loudness: number;\r\n};\r\n","import { LoudnessMessage, LoudnessType } from \"./message-types\";\r\n\r\n/**\r\n * EchoProcessor send the input data to the main thread via postMessage.\r\n */\r\nclass EchoProcessor extends AudioWorkletProcessor {\r\n\r\n    private processor: ProcessingBuffer;\r\n\r\n    constructor() {\r\n        super();\r\n        console.debug(\"EchoProcessor created\");\r\n\r\n        const FRAME_SIZE_S = 0.03;\r\n        const FRAMES = 100;\r\n\r\n        this.processor = new ProcessingBuffer(sampleRate, FRAME_SIZE_S, FRAMES, powers => {\r\n            // use weight of 1 for each channel\r\n            const weighting = () => 1;\r\n            this.onMomentaryLoudnessChange(momentaryLoudness(powers, FRAME_SIZE_S, weighting));\r\n            this.onShortTermLoudnessChange(shortTermLoudness(powers, FRAME_SIZE_S, weighting));\r\n        });\r\n    }\r\n\r\n    process(\r\n        inputs: Float32Array[][],\r\n        _outputs: Float32Array[][],\r\n        _parameters: Record<string, Float32Array>\r\n    ): boolean {\r\n        //only one input is provided, therefore only the audio channels of the first input are used\r\n        this.processor.appendData(inputs[0]);\r\n        return true;\r\n    }\r\n\r\n    onMomentaryLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.Momentary,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    onShortTermLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.ShortTerm,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    postMessage(msg: LoudnessMessage) {\r\n        this.port.postMessage(msg);\r\n    }\r\n}\r\n\r\nregisterProcessor('echo-processor', EchoProcessor);\r\n\r\nclass ProcessingBuffer {\r\n    private frameSamples: number;\r\n    private numFrames: number;\r\n    private rawBuffer: Float32RingBuffer[] = [];\r\n    //the calculated power values for each frame and each channel\r\n    private powerResults: number[][] = [];\r\n    private onPowerCallback: (powers: number[][]) => void;\r\n\r\n    constructor(sampleRate: number, frameSizeS: number, numFrames: number, onPowerCallback: (powers: number[][]) => void) {\r\n        this.frameSamples = sampleRate * frameSizeS;\r\n        this.numFrames = numFrames;\r\n        this.onPowerCallback = onPowerCallback;\r\n    }\r\n\r\n    appendData(inputs: Float32Array[]) {\r\n        inputs.forEach((inputData, channelInd) => {\r\n            if (!this.rawBuffer[channelInd]) {\r\n                this.rawBuffer[channelInd] = new Float32RingBuffer(this.frameSamples, data => {\r\n                    this.appendPower(channelInd, powerOfFrame(data));\r\n                });\r\n            }\r\n            this.rawBuffer[channelInd].push(inputData);\r\n        })\r\n    }\r\n\r\n    private appendPower(channel: number, power: number) {\r\n        if (!this.powerResults[channel]) {\r\n            this.powerResults[channel] = [];\r\n        }\r\n\r\n        this.powerResults[channel].unshift(power);\r\n\r\n        if (this.powerResults[channel].length >= this.numFrames) {\r\n            this.powerResults[channel] = this.powerResults[channel].slice(0, this.numFrames);\r\n        }\r\n\r\n        this.onPowerCallback(this.powerResults);\r\n    }\r\n}\r\n\r\nclass Float32RingBuffer {\r\n    private buffer: Float32Array;\r\n    private workingIndex: number = 0;\r\n    private callback: (data: Float32Array) => void;\r\n\r\n    constructor(length: number, onFull: (data: Float32Array) => void) {\r\n        this.buffer = new Float32Array(length);\r\n        this.callback = onFull;\r\n    }\r\n\r\n    push(pushData: Float32Array) {\r\n        for (const value of pushData) {\r\n            if (this.workingIndex >= this.buffer.length) {\r\n                this.callback(this.buffer.slice());\r\n                this.workingIndex = 0;\r\n            }\r\n            this.buffer[this.workingIndex] = value;\r\n            this.workingIndex++;\r\n        }\r\n    }\r\n}\r\n\r\nfunction powerOfFrame(data: Float32Array): number {\r\n    let sum = 0;\r\n    for (const value of data) {\r\n        sum += value * value;\r\n    }\r\n    return sum / data.length;\r\n}\r\n\r\nfunction momentaryLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\r\n    return loudnessOverTime(powers, frameSizeS, weighting, 0.4); //0.4 is 400ms momentary loudness\r\n}\r\n\r\nfunction shortTermLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\r\n    return loudnessOverTime(powers, frameSizeS, weighting, 3); //3 is 3s short term loudness\r\n}\r\n\r\nfunction loudnessOverTime(powers: number[][], frameSizeS: number, weighting: (channel: number) => number, timeS: number): number {\r\n    const numFrames = Math.round(timeS / frameSizeS); //0.4 is 400ms momentary loudness\r\n    let sum = 0;\r\n    for (const [channel, powersSet] of powers.entries()) {\r\n        const weight = weighting(channel);\r\n        let usedFrames = 0;\r\n        let tmpSum = 0;\r\n        for (const [frame, power] of powersSet.entries()) {\r\n            if (frame < numFrames) {\r\n                usedFrames++;\r\n                tmpSum += power;\r\n            }\r\n        }\r\n        sum += weight * (tmpSum / usedFrames);\r\n    }\r\n    return -0.691 + (10 * Math.log10(sum));\r\n}"],"names":["$a23239193c7b6ba4$export$aff430ca8978a0b9","LoudnessType","$97f5d456db901bfc$var$EchoProcessor","AudioWorkletProcessor","super","console","FRAMES","processor","ProcessingBuffer","weighting","$97f5d456db901bfc$var$ProcessingBuffer","sampleRate","FRAME_SIZE_S","powers","onMomentaryLoudnessChange","this","frameSizeS","shortTermLoudness","$97f5d456db901bfc$var$momentaryLoudness","onShortTermLoudnessChange","loudnessOverTime","timeS","$97f5d456db901bfc$var$shortTermLoudness","inputs","appendData","postMessage","loudness","type","Momentary","ShortTerm","msg","port","constructor","frameSamples","numFrames","onPowerCallback","appendPower","channelInd","rawBuffer","$97f5d456db901bfc$var$Float32RingBuffer","data","value","sum","momentaryLoudness","inputData","push","powerResults","power","channel","length","slice","callback","onFull","buffer","Float32Array","pushData","workingIndex","powersSet","weight","usedFrames","entries","tmpSum","frame","Math","log10"],"version":3,"file":"ebu-r128.worker.4a24ad14.js.map"}