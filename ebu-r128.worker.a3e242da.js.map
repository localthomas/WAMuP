{"mappings":"AAGA,IAAOA,E,IAAKC,WAAL,KACM,UAAG,YADJA,EAEC,UAAG,Y,MCKRC,UAAAC,sB,cAGAC,QACAC,QAAMC,MAAM,yBAEZ,MAAKC,EAAgBC,I,KAEjBD,UAAME,IAASC,EAAfC,WAAAC,EADA,KACAC,IAEA,MAAKC,QACRC,KAAAC,0B,SA0GRH,EAAAI,EAAAR,GAED,OAASS,EAAkBL,EAAoBI,EAAoBR,EAAgD,IA5G1GU,CAAAN,EAAAD,EAAAH,IACJM,KAAAD,0B,SA6GJD,EAAAI,EAAAR,GAED,OAASW,EAAiBP,EAAoBI,EAAoBR,EAAwCY,GA/GrGC,CAAAT,EAAAD,EAAAH,O,QAQGc,EAAKhB,EAAUiB,GAInBR,OAFCD,KAAAR,UAAAiB,WAAAD,EAAA,KAEDP,E,0BAEcf,G,iBACNwB,CAFaC,KAAA1B,EAAA2B,UAIpBF,a,0BAIaxB,G,iBACNwB,CAFaC,KAAA1B,EAAA4B,UAIpBH,a,YAIAI,GA7C6Cd,KAAAe,KAAAC,YAAAF,I,kBAqD7B,iBAHE3B,G,MAKX8B,EAGRC,UAAYtB,G,aACHuB,G,YACAC,EAAYA,EAAjBA,EAAAC,GACArB,KAAKqB,aAALzB,EAAuByB,EAC1BrB,KAAAoB,YAEDX,qBAAmCY,E,WAE3Bb,G,WAEac,GAAYC,KACpBvB,KAAAwB,UAAAD,KAAAvB,KAAAwB,UAAAD,GAAA,IAAAE,EAAAzB,KAAAmB,cAAAO,IAEL1B,KAAKwB,YAAUD,E,SA4CJI,GAEnB,IAAAC,EAAU,EACb,UAAAD,KAAAD,EAAAE,GAAAD,IAED,OAASE,WAjDmCC,CAAhCJ,QAEP1B,KAAAwB,UAAAD,GAAAQ,KAAAD,M,YAOQb,EAALe,GAEIhC,KAAKiB,aAAagB,KAASC,KAA3BjB,aAA0CG,GACrCH,IAGTjB,KAAKqB,gBAAqBJ,WAC7BjB,KAAAiB,aAAAgB,GAAAC,QAAAlC,KAAAoB,YAAApB,KAAAiB,aAAAgB,GAAAjC,KAAAiB,aAAAgB,GAAAE,MAAA,EAAAnC,KAAAoB,YArCkBpB,KAAAqB,gBAAArB,KAAAiB,e,MA6CnBC,E,aACI,E,YACKkB,EAAWC,GACnBrC,KAAAsC,OAAA,IAAAC,aAAAL,GAEGlC,KAACwC,SAAwBH,E,kBAGjBV,KAAKS,EACLpC,KAAKyC,cAALzC,KAAAsC,OAAAJ,SACHlC,KAAAoC,SAAApC,KAAAsC,OAAAH,SACDnC,KAAKsC,aAAYG,GAEpBzC,KAAAsC,OAAAtC,KAAAyC,cAAAd,EACJ3B,KAAAyC,gB,SAqBGb,EAAJ9B,EAAAI,EAAAR,EAAAY,GACA,MAAKc,EAAOa,KAASS,QAAc5C,G,IAC/B8B,EAAMe,E,IACN,MAAIC,EAAaF,KAAjB5C,EAAA+C,UAAA,CACA,MAAIC,EAAJpD,EAAAuC,GACA,IAAAW,EAAW,EAEHA,I,IACAE,MAAMC,EAANf,KAAAc,kBACHF,IAEFE,GAAUd,GAEjBJ,GAAOe,GAAeK,EAAKC,G","sources":["src/workers/audio-worklets/message-types.ts","src/workers/audio-worklets/ebu-r128.worker.ts"],"sourcesContent":["/**\r\n * LoudnessType is used to signal the type of a loudness value.\r\n */\r\nexport enum LoudnessType {\r\n    Momentary = \"momentary\",\r\n    ShortTerm = \"shortTerm\",\r\n};\r\n\r\n/**\r\n * LoudnessMessage is used as the message between an AudioWorklet and the main Thread.\r\n */\r\nexport type LoudnessMessage = {\r\n    type: LoudnessType;\r\n    loudness: number;\r\n};\r\n","import { LoudnessMessage, LoudnessType } from \"./message-types\";\r\n\r\n/**\r\n * EchoProcessor send the input data to the main thread via postMessage.\r\n */\r\nclass EchoProcessor extends AudioWorkletProcessor {\r\n\r\n    private processor: ProcessingBuffer;\r\n\r\n    constructor() {\r\n        super();\r\n        console.debug(\"EchoProcessor created\");\r\n\r\n        const FRAME_SIZE_S = 0.03;\r\n        const FRAMES = 100;\r\n\r\n        this.processor = new ProcessingBuffer(sampleRate, FRAME_SIZE_S, FRAMES, powers => {\r\n            // use weight of 1 for each channel\r\n            const weighting = () => 1;\r\n            this.onMomentaryLoudnessChange(momentaryLoudness(powers, FRAME_SIZE_S, weighting));\r\n            this.onShortTermLoudnessChange(shortTermLoudness(powers, FRAME_SIZE_S, weighting));\r\n        });\r\n    }\r\n\r\n    process(\r\n        inputs: Float32Array[][],\r\n        _outputs: Float32Array[][],\r\n        _parameters: Record<string, Float32Array>\r\n    ): boolean {\r\n        //only one input is provided, therefore only the audio channels of the first input are used\r\n        this.processor.appendData(inputs[0]);\r\n        return true;\r\n    }\r\n\r\n    onMomentaryLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.Momentary,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    onShortTermLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.ShortTerm,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    postMessage(msg: LoudnessMessage) {\r\n        this.port.postMessage(msg);\r\n    }\r\n}\r\n\r\nregisterProcessor('echo-processor', EchoProcessor);\r\n\r\nclass ProcessingBuffer {\r\n    private frameSamples: number;\r\n    private numFrames: number;\r\n    private rawBuffer: Float32RingBuffer[] = [];\r\n    //the calculated power values for each frame and each channel\r\n    private powerResults: number[][] = [];\r\n    private onPowerCallback: (powers: number[][]) => void;\r\n\r\n    constructor(sampleRate: number, frameSizeS: number, numFrames: number, onPowerCallback: (powers: number[][]) => void) {\r\n        this.frameSamples = sampleRate * frameSizeS;\r\n        this.numFrames = numFrames;\r\n        this.onPowerCallback = onPowerCallback;\r\n    }\r\n\r\n    appendData(inputs: Float32Array[]) {\r\n        inputs.forEach((inputData, channelInd) => {\r\n            if (!this.rawBuffer[channelInd]) {\r\n                this.rawBuffer[channelInd] = new Float32RingBuffer(this.frameSamples, data => {\r\n                    this.appendPower(channelInd, powerOfFrame(data));\r\n                });\r\n            }\r\n            this.rawBuffer[channelInd].push(inputData);\r\n        })\r\n    }\r\n\r\n    private appendPower(channel: number, power: number) {\r\n        if (!this.powerResults[channel]) {\r\n            this.powerResults[channel] = [];\r\n        }\r\n\r\n        this.powerResults[channel].unshift(power);\r\n\r\n        if (this.powerResults[channel].length >= this.numFrames) {\r\n            this.powerResults[channel] = this.powerResults[channel].slice(0, this.numFrames);\r\n        }\r\n\r\n        this.onPowerCallback(this.powerResults);\r\n    }\r\n}\r\n\r\nclass Float32RingBuffer {\r\n    private buffer: Float32Array;\r\n    private workingIndex: number = 0;\r\n    private callback: (data: Float32Array) => void;\r\n\r\n    constructor(length: number, onFull: (data: Float32Array) => void) {\r\n        this.buffer = new Float32Array(length);\r\n        this.callback = onFull;\r\n    }\r\n\r\n    push(pushData: Float32Array) {\r\n        for (const value of pushData) {\r\n            if (this.workingIndex >= this.buffer.length) {\r\n                this.callback(this.buffer.slice());\r\n                this.workingIndex = 0;\r\n            }\r\n            this.buffer[this.workingIndex] = value;\r\n            this.workingIndex++;\r\n        }\r\n    }\r\n}\r\n\r\nfunction powerOfFrame(data: Float32Array): number {\r\n    let sum = 0;\r\n    for (const value of data) {\r\n        sum += value * value;\r\n    }\r\n    return sum / data.length;\r\n}\r\n\r\nfunction momentaryLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\r\n    return loudnessOverTime(powers, frameSizeS, weighting, 0.4); //0.4 is 400ms momentary loudness\r\n}\r\n\r\nfunction shortTermLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\r\n    return loudnessOverTime(powers, frameSizeS, weighting, 3); //3 is 3s short term loudness\r\n}\r\n\r\nfunction loudnessOverTime(powers: number[][], frameSizeS: number, weighting: (channel: number) => number, timeS: number): number {\r\n    const numFrames = Math.round(timeS / frameSizeS); //0.4 is 400ms momentary loudness\r\n    let sum = 0;\r\n    for (const [channel, powersSet] of powers.entries()) {\r\n        const weight = weighting(channel);\r\n        let usedFrames = 0;\r\n        let tmpSum = 0;\r\n        for (const [frame, power] of powersSet.entries()) {\r\n            if (frame < numFrames) {\r\n                usedFrames++;\r\n                tmpSum += power;\r\n            }\r\n        }\r\n        sum += weight * (tmpSum / usedFrames);\r\n    }\r\n    return -0.691 + (10 * Math.log10(sum));\r\n}"],"names":["$a23239193c7b6ba4$export$aff430ca8978a0b9","LoudnessType","$97f5d456db901bfc$var$EchoProcessor","AudioWorkletProcessor","super","console","FRAMES","processor","ProcessingBuffer","weighting","$97f5d456db901bfc$var$ProcessingBuffer","sampleRate","FRAME_SIZE_S","powers","onShortTermLoudnessChange","this","onMomentaryLoudnessChange","frameSizeS","shortTermLoudness","$97f5d456db901bfc$var$momentaryLoudness","loudnessOverTime","timeS","$97f5d456db901bfc$var$shortTermLoudness","inputs","appendData","loudness","type","Momentary","ShortTerm","msg","port","postMessage","powerResults","constructor","frameSamples","numFrames","onPowerCallback","appendPower","channelInd","rawBuffer","$97f5d456db901bfc$var$Float32RingBuffer","data","value","sum","momentaryLoudness","inputData","push","power","channel","length","slice","callback","onFull","buffer","Float32Array","pushData","workingIndex","powersSet","weight","usedFrames","entries","tmpSum","frame","Math","log10"],"version":3,"file":"ebu-r128.worker.a3e242da.js.map"}