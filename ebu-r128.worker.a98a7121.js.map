{"mappings":"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","sources":["src/workers/audio-worklets/loudness-processing.ts","src/workers/audio-worklets/message-types.ts","src/workers/audio-worklets/ebu-r128.worker.ts"],"sourcesContent":["/** Defines an array of powers per audio channel. The first index is the channel. */\nexport type PowersOfWindow = number[][];\n\nexport class ProcessingBuffer {\n    private frameSamples: number;\n    private numFrames: number;\n    private rawBuffer: Float32RingBuffer[] = [];\n    /** the calculated power values for each frame and each channel */\n    private powerResults: PowersOfWindow = [];\n    private onPowerCallback: (powers: PowersOfWindow) => void;\n    private initCalled = false;\n\n    /**\n     * Creates a new ProcessingBuffer.\n     * @param sampleRate the sample rate of the audio data in Hz\n     * @param frameSizeS the frame size to use in seconds\n     * @param numFrames the number of frames inside one window of analysis\n     * @param onPowerCallback the callback is called as soon as sufficient power data is available for all channels; see `PowersOfWindow` as a reference\n     */\n    constructor(sampleRate: number, frameSizeS: number, numFrames: number, onPowerCallback: (powers: PowersOfWindow) => void) {\n        this.frameSamples = sampleRate * frameSizeS;\n        this.numFrames = numFrames;\n        this.onPowerCallback = onPowerCallback;\n    }\n\n    /**\n     * As the number of channels can only be determined when the first audio data arrives,\n     * this functions is meant to be called once when the first audio data was appended.\n     * @param numberOfChannels the number of channels of the first audio data\n     */\n    private init(numberOfChannels: number) {\n        if (!this.initCalled) {\n            // init the internal state of power results and number of channels\n            for (let channelId = 0; channelId < numberOfChannels; channelId++) {\n                this.powerResults[channelId] = [];\n            }\n        }\n        this.initCalled = true;\n    }\n\n    /**\n     * Processed a given set of audio data by appending it to the internal ring buffers.\n     * @param inputs the raw audio data as PCM float arrays\n     */\n    appendData(inputs: Float32Array[]) {\n        this.init(inputs.length);\n\n        let powers = Array(inputs.length);\n\n        inputs.forEach((inputData, channelInd) => {\n            if (!this.rawBuffer[channelInd]) {\n                this.rawBuffer[channelInd] = new Float32RingBuffer(this.frameSamples);\n            }\n            const evictedData = this.rawBuffer[channelInd].push(inputData);\n            const powersOfChannel = evictedData.map(data => powerOfFrame(data));\n            powers[channelInd] = powersOfChannel;\n        })\n\n        // assume that each channel has the same amount of power values\n        for (const powersOfChannel of powers) {\n            console.assert(powersOfChannel.length === powers[0].length);\n        }\n\n        // a frame is a value of power (i.e. one number) per channel\n        for (let frame = 0; frame < powers[0].length; frame++) {\n            for (let channel = 0; channel < powers.length; channel++) {\n                const power = powers[channel][frame];\n                this.powerResults[channel].unshift(power);\n\n                if (this.powerResults[channel].length >= this.numFrames) {\n                    this.powerResults[channel] = this.powerResults[channel].slice(0, this.numFrames);\n                }\n            }\n            // the callback is invoked on each frame\n            this.onPowerCallback(this.powerResults);\n        }\n    }\n}\n\nclass Float32RingBuffer {\n    private buffer: Float32Array;\n    private workingIndex: number = 0;\n\n    constructor(length: number) {\n        this.buffer = new Float32Array(length);\n    }\n\n    /**\n     * Push data into the ring buffer and return potentially evicted data.\n     * @param pushData the data to push into the ring buffer\n     * @returns a list with the evicted values; the `Float32Array` has always the length of the ring buffer; the list might be empty, if no values were evicted\n     */\n    push(pushData: Float32Array): Float32Array[] {\n        let finishedBuffers = [];\n        for (const value of pushData) {\n            if (this.workingIndex >= this.buffer.length) {\n                finishedBuffers.push(this.buffer.slice());\n                this.workingIndex = 0;\n            }\n            this.buffer[this.workingIndex] = value;\n            this.workingIndex++;\n        }\n        return finishedBuffers;\n    }\n}\n\nfunction powerOfFrame(data: Float32Array): number {\n    let sum = 0;\n    for (const value of data) {\n        sum += value * value;\n    }\n    return sum / data.length;\n}\n\nexport function momentaryLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\n    return loudnessOverTime(powers, frameSizeS, weighting, 0.4); //0.4 is 400ms momentary loudness\n}\n\nexport function shortTermLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\n    return loudnessOverTime(powers, frameSizeS, weighting, 3); //3 is 3s short term loudness\n}\n\nfunction loudnessOverTime(powers: number[][], frameSizeS: number, weighting: (channel: number) => number, timeS: number): number {\n    const numFrames = Math.round(timeS / frameSizeS); //0.4 is 400ms momentary loudness\n    let sum = 0;\n    for (const [channel, powersSet] of powers.entries()) {\n        const weight = weighting(channel);\n        let usedFrames = 0;\n        let tmpSum = 0;\n        for (const [frame, power] of powersSet.entries()) {\n            if (frame < numFrames) {\n                usedFrames++;\n                tmpSum += power;\n            }\n        }\n        sum += weight * (tmpSum / usedFrames);\n    }\n    return -0.691 + (10 * Math.log10(sum));\n}\n","/**\r\n * LoudnessType is used to signal the type of a loudness value.\r\n */\r\nexport enum LoudnessType {\r\n    Momentary = \"momentary\",\r\n    ShortTerm = \"shortTerm\",\r\n};\r\n\r\n/**\r\n * LoudnessMessage is used as the message between an AudioWorklet and the main Thread.\r\n */\r\nexport type LoudnessMessage = {\r\n    type: LoudnessType;\r\n    loudness: number;\r\n};\r\n","import { momentaryLoudness, ProcessingBuffer, shortTermLoudness } from \"./loudness-processing\";\r\nimport { LoudnessMessage, LoudnessType } from \"./message-types\";\r\n\r\n/**\r\n * EchoProcessor sends short term and momentary loudness to the main thread via postMessage.\r\n */\r\nclass EchoProcessor extends AudioWorkletProcessor {\r\n\r\n    private processor: ProcessingBuffer;\r\n\r\n    constructor() {\r\n        super();\r\n        console.debug(\"EchoProcessor created\");\r\n\r\n        const FRAME_SIZE_S = 0.03;\r\n        const FRAMES = 100;\r\n\r\n        this.processor = new ProcessingBuffer(sampleRate, FRAME_SIZE_S, FRAMES, powers => {\r\n            // use weight of 1 for each channel\r\n            const weighting = () => 1;\r\n            this.onMomentaryLoudnessChange(momentaryLoudness(powers, FRAME_SIZE_S, weighting));\r\n            this.onShortTermLoudnessChange(shortTermLoudness(powers, FRAME_SIZE_S, weighting));\r\n        });\r\n    }\r\n\r\n    process(\r\n        inputs: Float32Array[][],\r\n        _outputs: Float32Array[][],\r\n        _parameters: Record<string, Float32Array>\r\n    ): boolean {\r\n        //only one input is provided, therefore only the audio channels of the first input are used\r\n        this.processor.appendData(inputs[0]);\r\n        return true;\r\n    }\r\n\r\n    onMomentaryLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.Momentary,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    onShortTermLoudnessChange(loudness: number) {\r\n        this.postMessage({\r\n            type: LoudnessType.ShortTerm,\r\n            loudness\r\n        });\r\n    }\r\n\r\n    postMessage(msg: LoudnessMessage) {\r\n        this.port.postMessage(msg);\r\n    }\r\n}\r\n\r\nregisterProcessor('echo-processor', EchoProcessor);\r\n"],"names":["ProcessingBuffer","rawBuffer","powerResults","initCalled","constructor","sampleRate","frameSizeS","numFrames","onPowerCallback","this","frameSamples","init","numberOfChannels","channelId","appendData","inputs","length","powers","Array","forEach","inputData","channelInd","Float32RingBuffer","powersOfChannel","push","map","data","sum","value","powerOfFrame","console","assert","frame","channel","power","unshift","slice","workingIndex","buffer","Float32Array","pushData","finishedBuffers","momentaryLoudness","weighting","loudnessOverTime","shortTermLoudness","timeS","Math","round","powersSet","entries","weight","usedFrames","tmpSum","log10","$a23239193c7b6ba4$export$aff430ca8978a0b9","LoudnessType","Momentary","ShortTerm","EchoProcessor","AudioWorkletProcessor","super","debug","FRAME_SIZE_S","processor","onMomentaryLoudnessChange","onShortTermLoudnessChange","process","_outputs","_parameters","loudness","postMessage","type","msg","port","registerProcessor"],"version":3,"file":"ebu-r128.worker.a98a7121.js.map"}