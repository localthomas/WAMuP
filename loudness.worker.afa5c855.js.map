{"mappings":"AAwCO,SAASA,EAAwBC,GACpC,MAAO,CACHC,OAAQD,EAAME,KAAKC,IAAIC,GACvBC,QAASL,EAAMK,Q,CAoChB,SAASC,EAAyBC,GACrC,MAAMC,EAAmBD,EAAO,GAAGN,OAAOQ,OAK1C,IAAIR,EAAqB,GACzB,IAAK,IAAIS,EAAU,EAAGA,EAAUF,EAAkBE,IAAW,CACzD,IAAIC,EAA6B,GACjC,IAAK,MAAMX,KAASO,EAChBI,EAAmBA,EAAiBC,OAAOZ,EAAMC,OAAOS,IAE5DT,EAAOY,KAAKF,E,CAEhB,OAiBJ,SAA0BV,EAAoBI,GAC1CS,QAAQC,OAAOd,EAAOQ,SAAWJ,EAAQI,QACzC,IAAIO,EAAM,EACV,IAAK,MAAON,EAASO,KAAchB,EAAOiB,UAAW,CACjD,MAAMC,EAASd,EAAQK,GACvB,IAAIU,EAAa,EACbC,EAAS,EACb,IAAK,MAAOC,EAAGC,KAAUN,EAAUC,UAC/BE,IACAC,GAAUE,EAEdP,GAAOG,GAAUE,EAASD,E,CAE9B,OAGsBI,EAHLR,EAIA,GAAKS,KAAKC,MAAMF,GAA1B,KADJ,IAAmBA,C,CAjCfG,CAAiB1B,EAAQM,EAAO,GAAGF,Q,CAG9C,SAASD,EAAaF,GAClB,IAAIc,EAAM,EACV,IAAK,MAAMQ,KAAStB,EAChBc,GAAOQ,EAAQA,EAEnB,OAAOR,EAAMd,EAAKO,M,CCrGtB,MAAMmB,EAAiBC,KAUhB,IAA4CC,ICPtB,SAAUC,GAenC,OF0CG,SAA6CC,EAAaC,EAAoBC,GACjFpB,QAAQC,OAAOmB,GAAuBD,GAEtC,IAAIE,EAAa,GACjB,IAAK,IAAIC,EAAa,EAAGA,EAAaJ,EAAOvB,OAAQ2B,IAAc,CAE/D,MAAMC,EAAYZ,KAAKa,MAAMJ,EAAsBD,GAE7CM,EAAcP,EAAOQ,MAAMJ,EAAYA,EAAaC,GAC1DF,EAAWtB,KAAK0B,E,CAEpB,OAAOJ,C,CEzDiBM,CANTV,EAAMC,OAAO7B,IAAIJ,GAMiCgC,EAAME,WAAYF,EAAMG,qBAG1D/B,IAAIG,E,EDAnCsB,EAAOc,iBAAiB,WAAWC,MAAOC,IAEtC,MAAMb,EAAQa,EAAQ1C,MANN,SAAU0C,GAC1BhB,EAAOiB,YAAYD,E,CAUnBC,OAFqBf,EAAKC,GAE1B","sources":["src/miscellaneous/loudness-calculations.ts","src/workers/single-worker-base.ts","src/workers/loudness.worker.ts"],"sourcesContent":["// Note that this module does not import anything that might use import.meta.\n// This means it is safe to import in WebWorkers.\n\n/** A type as input for a worker calculating the loudness of an array of frames. */\nexport type LoudnessOfAudioBufferWorkerInput = {\n    frames: Frame[];\n    frameSizeS: number;\n    analysisWindowSizeS: number;\n}\n\n/** The power values of one frame. */\nexport type PowerOfFrame = {\n    /**\n     * The power values of each channel.\n     */\n    powers: number[];\n    /**\n     * One weight value per channel.\n     */\n    weights: number[];\n};\n\n\n/** One frame holds PCM data for a specified amount of time. */\nexport type Frame = {\n    /**\n     * The raw PCM data per channel.\n     */\n    data: Float32Array[];\n    /**\n     * One weight value per channel.\n     */\n    weights: number[];\n};\n\n/**\n * Calculates the power value per audio channel in this frame.\n * @param frame the frame with audio data\n * @returns the power value per channel\n */\nexport function powersPerChannelOfFrame(frame: Frame): PowerOfFrame {\n    return {\n        powers: frame.data.map(powerOfFrame),\n        weights: frame.weights,\n    };\n}\n\n/**\n * Creates a list of lists by combining multiple frames into one list, which is called an analysis window.\n * E.g. a list of 5 frames with each a length of 0.1s is combined into a list of 0.2s long analysis windows.\n * This results in a list of 5 windows, where each window has a 2 values in it.\n * Note that this means some values are stored in double\n * (e.g. in the first window there is one value which overlaps with the second window).\n *\n * From the example above: `[0, 1, 2, 3, 4]` becomes `[[0, 1], [1, 2], [2, 3], [3, 4], [4]]`.\n * @param frames the frames (values) which will be combined\n * @param frameSizeS how big one frame is in seconds\n * @param analysisWindowSizeS the size of one window in seconds (should be greater than frame size)\n * @returns a list of lists where the first index is the analysis window and the second is the index of the value within this window\n */\nexport function combineValuesIntoAnalysisWindows<T>(frames: T[], frameSizeS: number, analysisWindowSizeS: number): T[][] {\n    console.assert(analysisWindowSizeS >= frameSizeS);\n    /** the list of all windows; has the same length as the input parameter `frames` */\n    let allWindows = [];\n    for (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\n        /** the number of frames per window */\n        const numFrames = Math.round(analysisWindowSizeS / frameSizeS);\n        /** a list where all items for one window are stored */\n        const windowItems = frames.slice(frameIndex, frameIndex + numFrames);\n        allWindows.push(windowItems);\n    }\n    return allWindows;\n}\n\n/**\n * Calculate a loudness value for an analysis window with multiple frames and weighting.\n * @param window the window with frames\n * @returns the loudness value of all power values of the window\n */\nexport function loudnessOfAnalysisWindow(window: PowerOfFrame[]): number {\n    const numberOfChannels = window[0].powers.length;\n    /**\n     * a list of power values,\n     * where the first index is the channel and the second is the frame within the window\n     */\n    let powers: number[][] = [];\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n        let powersPerChannel: number[] = [];\n        for (const frame of window) {\n            powersPerChannel = powersPerChannel.concat(frame.powers[channel]);\n        }\n        powers.push(powersPerChannel);\n    }\n    return loudnessOfPowers(powers, window[0].weights);\n}\n\nfunction powerOfFrame(data: Float32Array): number {\n    let sum = 0;\n    for (const value of data) {\n        sum += value * value;\n    }\n    return sum / data.length;\n}\n\n/**\n * Convert a list of power values into an aggregated loudness value with weighting.\n * @param powers a list with the first index being the channel and the second the frame index\n * @param weights weights per channel\n * @returns the loudness value\n */\nfunction loudnessOfPowers(powers: number[][], weights: number[]): number {\n    console.assert(powers.length === weights.length);\n    let sum = 0;\n    for (const [channel, powersSet] of powers.entries()) {\n        const weight = weights[channel];\n        let usedFrames = 0;\n        let tmpSum = 0;\n        for (const [_, power] of powersSet.entries()) {\n            usedFrames++;\n            tmpSum += power;\n        }\n        sum += weight * (tmpSum / usedFrames);\n    }\n    return do10log10(sum);\n}\n\nexport function do10log10(value: number): number {\n    return -0.691 + (10 * Math.log10(value));\n}\n\nexport function undo10log10(value: number): number {\n    return Math.pow(10, ((value + 0.691) / 10))\n}\n","const worker: Worker = self as any;\n\n/**\n * Registers a function from a `*.worker.ts` file as a [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).\n * Only useful in conjunction with the `runSingleWorker` function in the module `miscellaneous/concurrent.ts`.\n *\n * The function is called within a WebWorker.\n * The function should not access anything other than the APIs available in WebWorkers.\n * @param func the function to execute\n */\nexport function registerSingleWorkerFunction<T, S>(func: (input: T) => S): void {\n    // note: the worker should post messages of type ItemWithIndex\n    // this is a typed function for easier checking\n    const postMessage = function (message: S): void {\n        worker.postMessage(message);\n    };\n\n    worker.addEventListener('message', async (message) => {\n        // note that there is no proper type checking!\n        const input = message.data as T;\n\n        // call the worker function and post the result as message\n        const result = await func(input);\n\n        postMessage(result);\n    });\n}","import { combineValuesIntoAnalysisWindows, loudnessOfAnalysisWindow, LoudnessOfAudioBufferWorkerInput, powersPerChannelOfFrame } from \"../miscellaneous/loudness-calculations\";\nimport { registerSingleWorkerFunction } from \"./single-worker-base\";\n\nregisterSingleWorkerFunction(function (input: LoudnessOfAudioBufferWorkerInput): number[] {\n    /**\n     * The power per channel per frame.\n     * The first index selects the frame number, the second is the channel number.\n     */\n    const powers = input.frames.map(powersPerChannelOfFrame);\n\n    /**\n     * The list with all combined frame data per window.\n     * The first index is the window and the second the index of the frame within the window.\n     */\n    const analysisWindows = combineValuesIntoAnalysisWindows(powers, input.frameSizeS, input.analysisWindowSizeS);\n\n    /** a list of loudness values per analysis window */\n    const result = analysisWindows.map(loudnessOfAnalysisWindow);\n    return result;\n});\n"],"names":["powersPerChannelOfFrame","frame","powers","data","map","powerOfFrame","weights","loudnessOfAnalysisWindow","window","numberOfChannels","length","channel","powersPerChannel","concat","push","console","assert","sum","powersSet","entries","weight","usedFrames","tmpSum","_","power","value","Math","log10","loudnessOfPowers","worker","self","func","input","frames","frameSizeS","analysisWindowSizeS","allWindows","frameIndex","numFrames","round","windowItems","slice","combineValuesIntoAnalysisWindows","addEventListener","async","message","postMessage"],"version":3,"file":"loudness.worker.afa5c855.js.map"}