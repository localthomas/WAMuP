{"mappings":"AAGO,MAAMA,EAGQC,UAAwB,GAErBC,aAAmB,GAErBC,YAAG,EASrBC,YAAYC,EAAoBC,EAAoBC,EAAmBC,GACnEC,KAAKC,aAAeL,EAAaC,EACjCG,KAAKF,UAAYA,EACjBE,KAAKD,gBAAkBA,C,CAQfG,KAACC,GACT,IAAKH,KAAKN,WAEN,IAAK,IAAIU,EAAY,EAAGA,EAAYD,EAAkBC,IAClDJ,KAAKP,aAAaW,GAAa,GAGvCJ,KAAKN,YAAa,C,CAOtBW,WAAWC,GACPN,KAAKE,KAAKI,EAAOC,QAEjB,IAAIC,EAASC,MAAMH,EAAOC,QAE1BD,EAAOI,SAAQ,CAACC,EAAWC,KAClBZ,KAAKR,UAAUoB,KAChBZ,KAAKR,UAAUoB,GAAc,IAAIC,EAAkBb,KAAKC,eAE5D,MACMa,EADcd,KAAKR,UAAUoB,GAAYG,KAAKJ,GAChBK,KAAIC,GAoDpD,SAAsBA,GAClB,IAAIC,EAAM,EACV,IAAK,MAAMC,KAASF,EAChBC,GAAOC,EAAQA,EAEnB,OAAOD,EAAMD,EAAKV,M,CAzDsCa,CAAaH,KAC7DT,EAAOI,GAAcE,CAArB,IAIJ,IAAK,MAAMA,KAAmBN,EAC1Ba,QAAQC,OAAOR,EAAgBP,SAAWC,EAAO,GAAGD,QAIxD,IAAK,IAAIgB,EAAQ,EAAGA,EAAQf,EAAO,GAAGD,OAAQgB,IAAS,CACnD,IAAK,IAAIC,EAAU,EAAGA,EAAUhB,EAAOD,OAAQiB,IAAW,CACtD,MAAMC,EAAQjB,EAAOgB,GAASD,GAC9BvB,KAAKP,aAAa+B,GAASE,QAAQD,GAE/BzB,KAAKP,aAAa+B,GAASjB,QAAUP,KAAKF,YAC1CE,KAAKP,aAAa+B,GAAWxB,KAAKP,aAAa+B,GAASG,MAAM,EAAG3B,KAAKF,W,CAI9EE,KAAKD,gBAAgBC,KAAKP,a,GAKtC,MAAMoB,EAEkBe,aAAW,EAE/BjC,YAAYY,GACRP,KAAK6B,OAAS,IAAIC,aAAavB,E,CAQnCQ,KAAKgB,GACD,IAAIC,EAAkB,GACtB,IAAK,MAAMb,KAASY,EACZ/B,KAAK4B,cAAgB5B,KAAK6B,OAAOtB,SACjCyB,EAAgBjB,KAAKf,KAAK6B,OAAOF,SACjC3B,KAAK4B,aAAe,GAExB5B,KAAK6B,OAAO7B,KAAK4B,cAAgBT,EACjCnB,KAAK4B,eAET,OAAOI,C,QC3FPC,UAAAC,sB,cAGAC,QACAd,QAAMe,MAAM,uC,KAIRC,UAAMC,IAAeC,EAA8BC,WAFlCjD,GACjB,GACmDiD,IAEnD,MAAKC,EAAYjC,EAAAQ,KAAAwB,KAAA,KACbhC,EAAQ8B,OADKI,GAAA,I,iBAEbC,CAFanC,OAAA8B,EAIpBK,WACJ,G,SAQGrC,EAAK+B,EAAUhC,GAInBoC,OAFCzC,KAAAqC,UAAAhC,WAAAC,EAAA,KAEU,C,aAEVsC,GAlC2D5C,KAAA6C,KAAAJ,YAAAG,EAqChEE,E","sources":["src/workers/audio-worklets/loudness-processing.ts","src/workers/audio-worklets/ebu-r128-100ms.worker.ts"],"sourcesContent":["/** Defines an array of powers per audio channel. The first index is the channel. */\nexport type PowersOfWindow = number[][];\n\nexport class ProcessingBuffer {\n    private frameSamples: number;\n    private numFrames: number;\n    private rawBuffer: Float32RingBuffer[] = [];\n    /** the calculated power values for each frame and each channel */\n    private powerResults: PowersOfWindow = [];\n    private onPowerCallback: (powers: PowersOfWindow) => void;\n    private initCalled = false;\n\n    /**\n     * Creates a new ProcessingBuffer.\n     * @param sampleRate the sample rate of the audio data in Hz\n     * @param frameSizeS the frame size to use in seconds\n     * @param numFrames the number of frames inside one window of analysis\n     * @param onPowerCallback the callback is called as soon as sufficient power data is available for all channels; see `PowersOfWindow` as a reference\n     */\n    constructor(sampleRate: number, frameSizeS: number, numFrames: number, onPowerCallback: (powers: PowersOfWindow) => void) {\n        this.frameSamples = sampleRate * frameSizeS;\n        this.numFrames = numFrames;\n        this.onPowerCallback = onPowerCallback;\n    }\n\n    /**\n     * As the number of channels can only be determined when the first audio data arrives,\n     * this functions is meant to be called once when the first audio data was appended.\n     * @param numberOfChannels the number of channels of the first audio data\n     */\n    private init(numberOfChannels: number) {\n        if (!this.initCalled) {\n            // init the internal state of power results and number of channels\n            for (let channelId = 0; channelId < numberOfChannels; channelId++) {\n                this.powerResults[channelId] = [];\n            }\n        }\n        this.initCalled = true;\n    }\n\n    /**\n     * Processed a given set of audio data by appending it to the internal ring buffers.\n     * @param inputs the raw audio data as PCM float arrays\n     */\n    appendData(inputs: Float32Array[]) {\n        this.init(inputs.length);\n\n        let powers = Array(inputs.length);\n\n        inputs.forEach((inputData, channelInd) => {\n            if (!this.rawBuffer[channelInd]) {\n                this.rawBuffer[channelInd] = new Float32RingBuffer(this.frameSamples);\n            }\n            const evictedData = this.rawBuffer[channelInd].push(inputData);\n            const powersOfChannel = evictedData.map(data => powerOfFrame(data));\n            powers[channelInd] = powersOfChannel;\n        })\n\n        // assume that each channel has the same amount of power values\n        for (const powersOfChannel of powers) {\n            console.assert(powersOfChannel.length === powers[0].length);\n        }\n\n        // a frame is a value of power (i.e. one number) per channel\n        for (let frame = 0; frame < powers[0].length; frame++) {\n            for (let channel = 0; channel < powers.length; channel++) {\n                const power = powers[channel][frame];\n                this.powerResults[channel].unshift(power);\n\n                if (this.powerResults[channel].length >= this.numFrames) {\n                    this.powerResults[channel] = this.powerResults[channel].slice(0, this.numFrames);\n                }\n            }\n            // the callback is invoked on each frame\n            this.onPowerCallback(this.powerResults);\n        }\n    }\n}\n\nclass Float32RingBuffer {\n    private buffer: Float32Array;\n    private workingIndex: number = 0;\n\n    constructor(length: number) {\n        this.buffer = new Float32Array(length);\n    }\n\n    /**\n     * Push data into the ring buffer and return potentially evicted data.\n     * @param pushData the data to push into the ring buffer\n     * @returns a list with the evicted values; the `Float32Array` has always the length of the ring buffer; the list might be empty, if no values were evicted\n     */\n    push(pushData: Float32Array): Float32Array[] {\n        let finishedBuffers = [];\n        for (const value of pushData) {\n            if (this.workingIndex >= this.buffer.length) {\n                finishedBuffers.push(this.buffer.slice());\n                this.workingIndex = 0;\n            }\n            this.buffer[this.workingIndex] = value;\n            this.workingIndex++;\n        }\n        return finishedBuffers;\n    }\n}\n\nfunction powerOfFrame(data: Float32Array): number {\n    let sum = 0;\n    for (const value of data) {\n        sum += value * value;\n    }\n    return sum / data.length;\n}\n\nexport function momentaryLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\n    return loudnessOverTime(powers, frameSizeS, weighting, 0.4); //0.4 is 400ms momentary loudness\n}\n\nexport function shortTermLoudness(powers: number[][], frameSizeS: number, weighting: (channel: number) => number): number {\n    return loudnessOverTime(powers, frameSizeS, weighting, 3); //3 is 3s short term loudness\n}\n\nfunction loudnessOverTime(powers: number[][], frameSizeS: number, weighting: (channel: number) => number, timeS: number): number {\n    const numFrames = Math.round(timeS / frameSizeS); //0.4 is 400ms momentary loudness\n    let sum = 0;\n    for (const [channel, powersSet] of powers.entries()) {\n        const weight = weighting(channel);\n        let usedFrames = 0;\n        let tmpSum = 0;\n        for (const [frame, power] of powersSet.entries()) {\n            if (frame < numFrames) {\n                usedFrames++;\n                tmpSum += power;\n            }\n        }\n        sum += weight * (tmpSum / usedFrames);\n    }\n    return -0.691 + (10 * Math.log10(sum));\n}\n","import { PowerOfFrame } from \"../../miscellaneous/loudness-calculations\";\r\nimport { ProcessingBuffer } from \"./loudness-processing\";\r\n\r\n/**\r\n * LoudnessFrame100msProcessor sends 100ms long loudness frames to the main thread via postMessage.\r\n */\r\nclass LoudnessFrame100msProcessor extends AudioWorkletProcessor {\r\n\r\n    private processor: ProcessingBuffer;\r\n\r\n    constructor() {\r\n        super();\r\n        console.debug(\"LoudnessFrame100msProcessor created\");\r\n\r\n        const FRAME_SIZE_S = 0.1;\r\n        const FRAMES = 1;\r\n\r\n        this.processor = new ProcessingBuffer(sampleRate, FRAME_SIZE_S, FRAMES, powers => {\r\n            // Note that in this specific case power is of number[][1], as FRAMES is 1\r\n            const powersConverted = powers.map(justOnePower => justOnePower[0]);\r\n            const weights = powers.map(_ => 1);\r\n            this.postMessage({\r\n                powers: powersConverted,\r\n                weights,\r\n            });\r\n        });\r\n    }\r\n\r\n    process(\r\n        inputs: Float32Array[][],\r\n        _outputs: Float32Array[][],\r\n        _parameters: Record<string, Float32Array>\r\n    ): boolean {\r\n        //only one input is provided, therefore only the audio channels of the first input are used\r\n        this.processor.appendData(inputs[0]);\r\n        return true;\r\n    }\r\n\r\n    postMessage(msg: PowerOfFrame) {\r\n        this.port.postMessage(msg);\r\n    }\r\n}\r\n\r\nregisterProcessor('loudness-frame-100ms-processor', LoudnessFrame100msProcessor);\r\n"],"names":["ProcessingBuffer","rawBuffer","powerResults","initCalled","constructor","sampleRate","frameSizeS","numFrames","onPowerCallback","this","frameSamples","init","numberOfChannels","channelId","appendData","inputs","length","powers","Array","forEach","inputData","channelInd","Float32RingBuffer","powersOfChannel","push","map","data","sum","value","powerOfFrame","console","assert","frame","channel","power","unshift","slice","workingIndex","buffer","Float32Array","pushData","finishedBuffers","$082a3860f2561162$var$LoudnessFrame100msProcessor","AudioWorkletProcessor","super","FRAMES","processor","powersConverted","$466479affc63f887$export$94548a684f5d392e","justOnePower","postMessage","_","weights","msg","port","registerProcessor"],"version":3,"file":"ebu-r128-100ms.worker.87b30ad8.js.map"}